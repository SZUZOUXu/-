### 内存四区
- 代码区  
存放函数体的**二进制代码**，由操作系统进行管理的。**共享、只读**。
- 全局区  
存放**全局变量和静态变量（static）以及常量**（const修饰的全局变量、字符串常量）
- 堆区  
**new出来的**；由程序员分配和释放，若程序员不释放，程序结束后由**操作系统回收**。
- 栈区  
由**编译器自动分配释放**，存放**函数的参数值，局部变量**等。

### c语言每种类型变量占的字节数
- char存储大小1字节，值范围-128~127；
- unsigned char存储大小1字节，值范围0~255；unsigned short等同理
- short存储大小2字节，值范围-32768~32767；
- int  
16位系统存储大小2字节，值范围-32768 ~ 32767  
32、64位系统存储大小4字节，值范围-2^31 ~ 2^31-1（大约-10^9 ~ 10^9）
- long  
16、32位系统存储大小4字节，值范围0 ~ 2^32-1（大约0 ~ 2 * 10^9）  
64位系统存储大小8字节，值范围9 * 10^18
- long long
存储大小8字节，值范围-2^63 ~ 2^63-1（大约9 * 10^18）
- float  
4字节  -3.4 * 10^38~3.4 * 10^38 
- double  
8字节  -1.7 * 10^308~1.7 * 10^308
- long double  
8字节  -1.7 * 10^308~1.7 * 10^308

### 指针
指针使得 C 语言能够更高效地实现对计算机底层硬件的操作，而计算机硬件的操作很大程度上依赖地址，指针便提供了一种对地址操作的方法
- 指针本身也是一个变量  
地址是指针的地址；数据是指向对象的地址。char * 、double * 和 int *
- 指针加减  
加/减的是整个指针类型的长度，不如说成指针的偏移更合适。
### const与define的区别
1. 汇编的角度  
const给出**内存地址**，而define给出**立即数**，即const在内存中仅有一份拷贝，而define有多份。
2. 效率角度  
编译器通常不为普通const常量**分配存储空间**，⽽是将它们保存在符号表中，使得const的效率比较高。
3. 编译器处理方式  
define是在**预处理阶段**展开，const常量是**编译运行阶段**使用。
4. 类型和安全检查不同  
define没有类型，没有类型检查；const有数据类型，在编译运行阶段检查类型。
5. 可否修改  
const修饰的量不是常量，仅仅是个只读量，**可以通过指针进行修改**。

### gcc,make和cmake的区别
- gcc是编译器
- make可以批处理gcc命令，需要编写makefile
- cmake可以简化编写makefile的过程

### C/C++的区别
1. C语言是**面向过程**语言，⽽C++是**面向对象**语言
2. 函数重载  
C语言不存在函数重载，C++根据函数名参数个数参数类型判断重载。（属于静多态，必须同一作用域下才叫重载）
3. 缺省参数  
缺省参数是声明或定义函数时为函数的参数指定一个**默认值**。在调用该函数时，如果没有指定实参则采用该默认值，否则使⽤指定的参数。  
C语言不支持缺省参数，C++支持。
4. 默认返回类型  
C语言中，如果⼀个函数没有指定返回值类型，**默认返回int类型**；C++中，如果⼀个函数**没有返回值则必须指定为void**。
5. 未指定参数列表  
在C语言中，函数没有指定参数列表时，默认可以接收**任意多个参数**；但在C++中，因为严格的**参数类型检测**，没有参数列表的函数，**默认为 void，不接收任何参数**。
6. malloc,free && new,delete  
都可以用来在堆上分配和回收空间。  

### malloc,free && new,delete 
执行new的过程：
- 分配**未初始化的内存空间**（malloc）
- **对象的构造函数**对空间进行初始化，返回空间的**首地址**；构造对象时出现异常，则自动调用 delete 释放内存。

执行delete的过程：
- 使用对象的析构函数对对象进行析构。
- 回收内存空间（free）
可以看出**区别**：new 得到的是**经过初始化的空间**，⽽ malloc 得到的是**未初始化的空间**。
### 初始化列表
1. 显式的调用基类带参构造函数
- 初始化列表中**无法直接初始化基类的数据成员**，所以你需要在列表中**指定基类的构造函数**，如果不指定，编译器则会**调用基类的默认构造函数**。
- 要显式的调用基类Base()带参构造函数->**初始化列表**。
```C++
BaseChild():Base(1)
{
    cout << "create is BaseChild()" << endl;
}
```
2. 可以初始化类本身的数据成员
对BaseChild成员m_num进行初始化
```C++
BaseChild():Base(1), m_num(0){...};//调用基类Base的构造函数，对BaseChild成员m_num进行初始化
```
3. 这样初始化成员效率高
它会比在函数体内初始化派生类成员更快，这是因为在**分配内存**后，在**函数体内又多进行了一次赋值操作**。

4. 初始化类本身的数据成员的顺序
初始化列表并不能指定初始化的顺序，正确的顺序是，首先初始化基类，其次根据**派生类成员声明次序**依次初始化。

### 构造函数特点
1. 如果没有定义任何构造函数，C++编译器会自动创建一个默认构造函数。  
2. 如果已经定义了一个构造函数，编译器不会自动创建默认构造函数，只能显式调用该构造函数。

### 构造函数可以是虚函数吗
1. 对象的内存空间尚未初始化  
虚函数对应一个**虚指针**，虚指针其实是**存储在对象的内存空间**的。如果构造函数是虚的，对象还没有实例化，也就是内存空间还没有，就没有虚指针，所以构造函数不能是虚函数。
2. 不能通过父类的指针或者引用去调用  
虚函数的作用在于通过**父类的指针或者引用**来调用它的时候能够变成**子类的那个成员函数**。而构造函数是在**创建对象时自动调用的**，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。

### 抽象函数和虚函数的区别
1. 是否需要重写  
虚函数是有代码的并明确允许子类去覆盖，但子类也可不覆盖，就是说可以直接用，**不用重写**；抽象函数是没有代码，**子类继承后⼀定要重写**。
2. 虚函数变为抽象函数  
在**virtual函数后⾯写上=0**，虚函数就成了纯虚函数，也就是抽象函数，包含抽象函数的类称为**抽象类**。

### 面向对象三大特征
1. 封装:  
封装就是把**过程和数据包围起来**，对数据的访问只能**通过特定的界面**。能**降低耦合性**。

2. 继承：  
子类继承父类的特征和行为。
子类可以**有父类的方法，属性（非private）**。子类也可以对父类进行**扩展**，也可以**重写**父类类的方法。缺点就是**提高代码之间的耦合性**。
- super关键字：通过super实现对父类成员的访问。用来**引用当前对象的父类**。通过super显试调用父类的有参构造，无参构造可以隐式调用。
- this：用来**引用当前对象**，指向自己。
- final：可以**修饰类，方法**，修饰的**类不能继承**，修饰的**方法不能重写**，修饰的**属性不能修改**。
- private/protected：
在没有继承的情况下，protected跟private相同。在派生类的时候才出现分化。  
父类对象不能访问父类的protected成员，**子类中可以访问父类的protected成员**。也就是说private成员是不能被继承的

3. **多态**：  
多态就是**相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作**，说白点就是**调用哪个虚函数，取决于引用的对象**是哪种类型的对象。
- 编译时多态性（静态多态）：通过重载函数实现
- 运行时多态性（动态多态）：通过虚函数实现 
C++**运行时多态性**是通过**虚函数来实现**的，**虚函数允许子类重新定义成员函数**，而子类重新定义父类的做法称为覆盖(Override)，或者称为**重写**。
多态最常见的用法就是**声明父类类型的指针，利用该指针指向任意一个子类对象**，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。


**理解多态**（假如有⼀个父类Father和子类Children）
- 向上转型是自动的 Father f = new Children();不需要强转
- 向下转型需要强转 Children c = (Children)new Father()需要强转。让父类知道具体转成哪个子类
- 父类引用指向子类对象，子类重写了父类的方法，调用⽗类的方法，实际是调用子类重写⽗类的方法后的方法。  
父类f指向子类Children对象，`Father f = new Children();f.toString()`实际是调⽤子类重写后的方法。

### 出栈序列个数
卡特兰数:对于n个不同元素进栈,出栈序列的个数为 (1/n+1) * C^(n)(2n)
