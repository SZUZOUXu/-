### const与define的区别
1. 汇编的角度  
const给出**内存地址**，而define给出**立即数**，即const在内存中仅有一份拷贝，而define有多份。
2. 效率角度  
编译器通常不为普通const常量**分配存储空间**，⽽是将它们保存在符号表中，使得const的效率比较高。
3. 编译器处理方式  
define是在**预处理阶段**展开，const常量是**编译运行阶段**使用。
4. 类型和安全检查不同  
define没有类型，没有类型检查；const有数据类型，在编译运行阶段检查类型。
5. 可否修改  
const修饰的量不是常量，仅仅是个只读量，**可以通过指针进行修改**。

### gcc,make和cmake的区别
- gcc是编译器
- make可以批处理gcc命令，需要编写makefile
- cmake可以简化编写makefile的过程

### C/C++的区别
1. C语言是**面向过程**语言，⽽C++是**面向对象**语言
2. 函数重载  
C语言不存在函数重载，C++根据函数名参数个数参数类型判断重载。（属于静多态，必须同一作用域下才叫重载）
3. 缺省参数  
缺省参数是声明或定义函数时为函数的参数指定一个**默认值**。在调用该函数时，如果没有指定实参则采用该默认值，否则使⽤指定的参数。  
C语言不支持缺省参数，C++支持。
4. 默认返回类型  
C语言中，如果⼀个函数没有指定返回值类型，**默认返回int类型**；C++中，如果⼀个函数**没有返回值则必须指定为void**。
5. 未指定参数列表  
在C语言中，函数没有指定参数列表时，默认可以接收**任意多个参数**；但在C++中，因为严格的**参数类型检测**，没有参数列表的函数，**默认为 void，不接收任何参数**。
6. malloc,free && new,delete  
都可以用来在堆上分配和回收空间。  

### malloc,free && new,delete 
执行new的过程：
- 分配**未初始化的内存空间**（malloc）
- **对象的构造函数**对空间进行初始化，返回空间的**首地址**；构造对象时出现异常，则自动调用 delete 释放内存。

执行delete的过程：
- 使用对象的析构函数对对象进行析构。
- 回收内存空间（free）
可以看出**区别**：new 得到的是**经过初始化的空间**，⽽ malloc 得到的是**未初始化的空间**。
### 初始化列表
1. 显式的调用基类带参构造函数
- 初始化列表中**无法直接初始化基类的数据成员**，所以你需要在列表中**指定基类的构造函数**，如果不指定，编译器则会**调用基类的默认构造函数**。
- 要显式的调用基类Base()带参构造函数->**初始化列表**。
```C++
BaseChild():Base(1)
{
    cout << "create is BaseChild()" << endl;
}
```
2. 可以初始化类本身的数据成员
对BaseChild成员m_num进行初始化
```C++
BaseChild():Base(1), m_num(0){...};//调用基类Base的构造函数，对BaseChild成员m_num进行初始化
```
3. 这样初始化成员效率高
它会比在函数体内初始化派生类成员更快，这是因为在**分配内存**后，在**函数体内又多进行了一次赋值操作**。

4. 初始化类本身的数据成员的顺序
初始化列表并不能指定初始化的顺序，正确的顺序是，首先初始化基类，其次根据**派生类成员声明次序**依次初始化。

## 构造函数
如果没有定义任何构造函数，C++编译器会自动创建一个默认构造函数。
如果已经定义了一个构造函数，编译器不会自动创建默认构造函数，只能显式调用该构造函数。
